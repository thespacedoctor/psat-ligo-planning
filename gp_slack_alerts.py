#!/usr/bin/env python
# encoding: utf-8
"""
*This gocart plugin will trigger a slack alert whenever a new event alert arrives*

Before using this plugin in a gocart environment run the following:

```bash
conda install slack-sdk -c conda-forge
```

:Author:
    David Young

:Date Created:
    June 9, 2023

Usage:
    gp_slack_alerts.py <alertDir>

Options:
    alertDir              path to an alert directory

    -h, --help            show this help message
    -v, --version         show version
"""
################# GLOBAL IMPORTS ####################
import sys
import os
from fundamentals import tools
from fundamentals.mysql import writequery
from fundamentals.mysql import readquery
from fundamentals.renderer import list_of_dictionaries
from datetime import datetime, date, time
from slack_sdk import WebClient
import pandas as pd
import sqlite3 as sql


def plugin(
        log,
        settings,
        alertFiles,
        alertMeta,
        dbConn,
        alertDir):
    """*this is the gocart plugin function that will be run when an alert is read*

    **Key Arguments:**

    - ``log`` -- logger
    - ``settings`` -- these are the gocart settings, you can add extra settings to the gocart.yaml settings file and they will be read here.
    - ``alertFiles`` -- a list of all the files generated by gocart for the alert
    - ``alertMeta`` -- a dictionary of the alert metadata from the json alert, FITS Heaeder and gocart generated extras.
    - ``dbConn`` -- the database connection
    - ``alertDir`` -- path to the alert directory
    """
    log.debug('starting the ``plugin`` function')

    client = WebClient(settings["slack"]["bot_token"])

    # GRAB EVENT METADATA
    eventId = alertMeta["ALERT"]["superevent_id"]
    alertType = alertMeta["ALERT"]["alert_type"]
    alertTime = alertMeta["ALERT"]["time_created"].replace("Z", "")

    def dict_factory(cursor, row):
        d = {}
        for idx, col in enumerate(cursor.description):
            d[col[0]] = row[idx]
        return d

    # HAVE WE POSTED THIS ALERT BEFORE
    conn = get_sqlite_dbconn(log=log)
    conn.row_factory = dict_factory
    c = conn.cursor()
    sqlQuery = f"select count(*) as count from events where eventid = '{eventId}' and alertTime = '{alertTime}'"
    c.execute(sqlQuery)
    threads = c.fetchall()
    count = threads[0]['count']
    if count:
        print(f"The {alertType} alert {eventId} has already been posted to slack")
        return

    # DETERMINE WHICH CHANNEL TO POST TO
    significant = None
    if 'event' in alertMeta['ALERT'] and alertMeta['ALERT']['event']:
        if "significant" in alertMeta['ALERT']['event']:
            significant = alertMeta['ALERT']['event']["significant"]
    if significant == False:
        channel = "low-significance"
    elif significant == True:
        channel = "high-significance"

    if alertType == "RETRACTION":
        sqlQuery = f"select channel from events where eventid = '{eventId}'"
        c.execute(sqlQuery)
        threads = c.fetchall()
        if not len(threads):
            # NOT ALERTED ON THIS BEFORE
            log.error(f"Have not seen event {eventId} before. Can't determine which channel to post this retraction too.")
            return
        else:
            channel = threads[0]['channel']

    if "debug" in settings["slack"] and settings["slack"]["debug"] and "test-" not in channel:
        channel = "test-" + channel

    # DETERMINE TAGS TO ADD TO ALERT
    if alertType != "RETRACTION":
        tags = []
        if 'event' in alertMeta['ALERT'] and alertMeta['ALERT']['event']:
            if "group" in alertMeta['ALERT']['event'] and alertMeta['ALERT']['event']["group"].lower() == "burst":
                tags.append("BURST")

        if 'event' in alertMeta['ALERT'] and "classification" in alertMeta['ALERT']['event'] and len(alertMeta['ALERT']['event']['classification']):
            for k, v in alertMeta['ALERT']['event']['classification'].items():
                if v > 0.1:
                    tags.append(k)
        if len(tags):
            tags = "*#" + ("* *#").join(tags) + "* "
        else:
            tags = ""
    else:
        tags = ""

    # HAS THE EVENT BEEN POSTED BEFORE
    sqlQuery = f"select thread_id from events where eventId = '{eventId}'"
    c.execute(sqlQuery)
    threads = c.fetchall()
    if len(threads):
        alertNumber = len(threads) + 1
        ts = str(threads[0]['thread_id'])
    else:
        ts = None
        alertNumber = 1

    mapUrl = ""
    metaUrl = False
    for f in alertFiles:
        basename = os.path.basename(f)
        if basename == "meta.yaml":
            upload_text_file = client.files_upload_v2(
                title=f"{alertType} metadata for {eventId}",
                file=f"{f}",
                initial_comment="Here is the metadata ..."
            )
            metaUrl = upload_text_file["file"]["permalink"]
        if basename == "skymap.png":
            upload_text_file = client.files_upload_v2(
                title=f"{alertType} skymap for {eventId}",
                file=f"{f}",
                initial_comment="Here is the file:",
            )
            mapUrl = upload_text_file["file"]["permalink"]

    # POST MESSAGE
    response = client.chat_postMessage(
        text=f"{eventId}: {alertType} alert for {tags}event. {mapUrl}",
        channel=channel,
        blocks=[
            {
                "type": "section",
                "text": {
                    "type": "mrkdwn",
                    "text": f"*<https://gracedb.ligo.org/superevents/{eventId}|{eventId}>*: {alertType} alert for {tags}event (Alert number {alertNumber} for this event)."
                },
            }
        ]
    )
    ts = response['ts']

    sqlQuery = f"insert into events (eventid, channel, thread_id, alertTime) values ('{eventId}','{channel}','{ts}', '{alertTime}')"
    c.execute(sqlQuery)
    conn.commit()
    c.close()

    if metaUrl:
        response = client.chat_postMessage(
            text=f"{eventId}: metadata. {metaUrl}",
            channel=channel,
            blocks=[
                {
                    "type": "section",
                    "text": {
                        "type": "mrkdwn",
                        "text": f"*<https://gracedb.ligo.org/superevents/{eventId}|{eventId}>*: {alertType} alert metadata."
                    },
                }
            ],
            thread_ts=ts,
            reply_broadcast=False
        )

    return


# DO NOT EDIT ANYTHING BOTH THIS LINE
def main(arguments=None):
    """
    *The main function used when ``gp_template.py`` is run as a single script from the cl*
    """

    # SETUP THE COMMAND-LINE UTIL SETTINGS
    su = tools(
        arguments=arguments,
        docString=__doc__,
        logLevel="WARNING",
        options_first=False,
        projectName="gocart",
        defaultSettingsFile=True
    )
    arguments, settings, log, dbConn = su.setup()

    # UNPACK REMAINING CL ARGUMENTS USING `EXEC` TO SETUP THE VARIABLE NAMES
    # AUTOMATICALLY
    a = {}
    for arg, val in list(arguments.items()):
        if arg[0] == "-":
            varname = arg.replace("-", "") + "Flag"
        else:
            varname = arg.replace("<", "").replace(">", "")
        a[varname] = val
        if arg == "--dbConn":
            dbConn = val
            a["dbConn"] = val
        log.debug('%s = %s' % (varname, val,))

    # GENERATE A LIST OF FILE PATHS
    pathToDirectory = a["alertDir"]
    alertFiles = []
    alertMeta = None
    for d in os.listdir(pathToDirectory):
        filepath = os.path.join(pathToDirectory, d)
        if os.path.isfile(filepath) and d[0] != ".":
            alertFiles.append(filepath)

        if d == "meta.yaml":
            import yaml
            # ADD YAML CONTENT TO DICTIONARY
            with open(filepath, 'r') as stream:
                alertMeta = yaml.safe_load(stream)

    plugin(
        log=log,
        settings=settings,
        alertFiles=alertFiles,
        alertMeta=alertMeta,
        dbConn=dbConn,
        alertDir=pathToDirectory
    )

    return


def get_sqlite_dbconn(
        log):
    """*get the sqlite database connection used to cache slack thread IDs*

    **Key Arguments:**

    - `log` -- logger
    """
    log.debug('starting the ``get_sqlite_dbconn`` function')

    dbPath = os.path.dirname(__file__) + "/slack_cache.db"
    if not os.path.exists(dbPath):
        conn = sql.connect(dbPath)
        c = conn.cursor()
        sqlQuery = """
        CREATE TABLE IF NOT EXISTS "events" (
          "eventid" text,
          "thread_id" text,
          "channel" text,
          "alertTime" timestamp NOT NULL ON CONFLICT IGNORE,
          UNIQUE ("alertTime")
        );
        """
        c.execute(sqlQuery)
        c.close()

    conn = sql.connect(dbPath)

    log.debug('completed the ``get_sqlite_dbconn`` function')
    return conn

# use the tab-trigger below for new function
# xt-def-function


if __name__ == '__main__':
    main()
